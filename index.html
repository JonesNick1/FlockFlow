<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FlockFlow</title>

  <style>
    :root{
      --panel: #e9eef9;
      --panelBorder: #b7c7ee;
      --shadow: 0 2px 10px rgba(0,0,0,0.06);
      --bg: #f3f5f8;
      --text: #141414;
      --muted: #555;
      --border: #d0d0d0;
      --card: #ffffff;
      --card2: #f7f9ff;
      --btn: #f6f6f6;
      --btnBorder: #8d8d8d;
      --thead: #eef1f6;
      --pill: #fff7e6; 
      --pillBorder: #e0b45a;
      --dangerBg: #ffecec;
      --dangerBorder: #c66;
      --accent: #2b6cff;
      --accentBorder: #1f4fbf;
      --softAccent: #eaf1ff;
      --softAccentBorder: #2b6cff;
    }
    [data-theme="dark"]{
      --bg: #0f141a;
      --text: #e9edf3;
      --muted: #a9b3bf;
      --border: #2b3340;
      --card: #151c25;
      --card2: #121a24;
      --btn: #1b2430;
      --btnBorder: #3a475a;
      --thead: #1a2431;
      --pill: #2b2416;
      --pillBorder: #8a6a2a;
      --dangerBg: #3a1b1b;
      --dangerBorder: #b05a5a;
      --softAccent: rgba(43,108,255,0.18);
      --softAccentBorder: rgba(43,108,255,0.75);
      --panel: #101a26;
      --panelBorder: #2f4363;
      --shadow: 0 2px 10px rgba(0,0,0,0.35);
    }

    body{
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 16px;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{ max-width:1200px; margin:0 auto; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .muted{ color: var(--muted); }
    .big{ font-size:28px; font-weight:800; }
    .kpi{ font-size:18px; font-weight:800; }

    .card{
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
      margin:12px 0;
      background: var(--card);
      box-shadow: var(--shadow);
    }
    /* Force "inner cards" to stay white, even when nested inside a blue panel */
    .cardInner{
     background: var(--card) !important;
     border-color: var(--border) !important;
    }
    .cardPop{
      background: var(--panel);
      border-color: var(--panelBorder);
    }
.tabContent{
  max-width: 980px;
  margin: 0 auto;
}
.pageWrap{
  max-width: 1200px;
  margin: 0 auto;
}
    .btn{
      cursor:pointer;
      user-select:none;
      border:1px solid var(--btnBorder);
      background: var(--btn);
      border-radius:14px;
      padding:14px 16px;
      font-size:20px;
      color: var(--text);
    }
    .btn:active{ transform:scale(0.98); }
    .btnWide{ min-width:170px; }
    .btnSmall{ padding:10px 12px; font-size:16px; border-radius:12px; }

    input{
      font-size:16px;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background: color-mix(in srgb, var(--card) 92%, var(--bg) 8%);
      color: var(--text);
    }

    .danger{ background: var(--dangerBg); border-color: var(--dangerBorder); }

    .nav{ display:flex; gap:8px; flex-wrap:wrap; margin: 10px 0; }
    .nav .btn{ padding:10px 12px; font-size:16px; }
    /* Global header */
.appHeader{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
  margin: 6px 0 10px;
}
.appTitle{
  margin: 0;
  font-size: 26px;
  font-weight: 800;
  letter-spacing: 0.2px;
}
.appSubtitle{
  margin-top: 4px;
  color: var(--muted);
}
.userBadge{
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 12px;
  border-radius:999px;
  border:1px solid var(--border);
  background: color-mix(in srgb, var(--card) 90%, var(--bg) 10%);
  font-size:13px;
  color: var(--muted);
  white-space:nowrap;
}
.userMenu details { position: relative; }
.userMenu summary { list-style: none; }
.userMenu summary::-webkit-details-marker { display:none; }

.userPill{
  display:flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:999px;
  border:1px solid var(--border);
  background: color-mix(in srgb, var(--card) 92%, var(--bg) 8%);
  cursor:pointer;
  font-size:14px;
  font-weight:700;
}

.userDropdown{
  position:absolute;
  right:0;
  top: calc(100% + 8px);
  width: 240px;
  background: var(--card);
  border:1px solid var(--border);
  border-radius:14px;
  box-shadow: var(--shadow);
  padding:12px;
  z-index: 99999;
}
.userDot{
  width:8px;
  height:8px;
  border-radius:50%;
  background: color-mix(in srgb, var(--accent) 65%, #999 35%);
}
    .topBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin: 10px 0;
    }
    
    .modeBtn{
      margin-left:auto;
    }
    .twoCol{ display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 980px) { .twoCol { grid-template-columns: 1fr; } }

    table{ border-collapse: collapse; width:100%; }
    td, th{
      border:1px solid var(--border);
      padding:10px;
      text-align:left;
    }
    th {
      text-align: center;
      font-weight: 700;
      letter-spacing: 0.3px;
    }
    th{ background: var(--thead); }

    .pill{
      display:inline-block;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--pillBorder);
      background: var(--pill);
      font-size:14px;
    }
    .pill.ok{ background: color-mix(in srgb, #00ff6a 16%, var(--card) 84%); border-color: color-mix(in srgb, #00ff6a 35%, var(--border) 65%); }

    .selectedBlue{
      background: var(--accent) !important;
      color: white !important;
      border-color: var(--accentBorder) !important;
    }

    .softBlue{
      background: var(--panel);
      border-color: var(--panelBorder);
    }

    .disabled{ opacity:0.45; pointer-events:none; }

    /* Eggs page */
    .boxGrid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(76px,1fr)); gap:10px; }
    .boxBtn{ width:100%; min-width:0; font-size:16px; padding:10px; border-radius:12px; }
    /* Slightly bigger nest buttons for Pen 2 and Pen 3 only */
    #pen2Boxes .boxBtn,
    #pen3Boxes .boxBtn{
      font-size: 18px;
      padding: 12px 10px;
    }
.gateOverlay{
  position: fixed;
  inset: 0;
  display: none;              /* toggled by JS */
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(15, 18, 25, 0.45);
  backdrop-filter: blur(10px);
  z-index: 99999;
}

.gateCard{
  width: min(520px, 100%);
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 16px 16px 14px;
}

.gateGrid{
  display: grid;
  gap: 12px;
}

.gateInput{
  width: 100%;
  padding: 12px 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--card2);
  color: var(--text);
  outline: none;
}
/* Ensure everything measures width sanely */
* { box-sizing: border-box; }

/* Keep child elements clipped to the card */
.gateCard{
  overflow: hidden;
}

/* Make the grid and its children never exceed the card width */
.gateGrid{ width: 100%; }

.gateInput{
  width: 100%;
  max-width: 100%;
  display: block;
}

#btnGateSignIn{
  width: 100%;
  max-width: 100%;
  display: block;
}
.gateInput:focus{
  border-color: var(--panelBorder);
}
    /* Slightly wider grid sizing so buttons don't look cramped */
    #pen2Boxes,
    #pen3Boxes{
      grid-template-columns: repeat(auto-fit, minmax(88px, 1fr));
    }
    .holesGrid{ display:grid; grid-template-columns:repeat(5,minmax(90px,1fr)); gap:10px; }
    @media (max-width:700px){ .holesGrid{ grid-template-columns:repeat(4,minmax(80px,1fr)); } }

    .sectionTitle{ margin:0 0 6px; }
    .houseLabel{ font-weight:800; margin-bottom:8px; }
  </style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>

<body>
<div id="loginGate" class="gateOverlay" style="display:none;">
  <div class="gateCard">
    <h3 style="margin:0 0 6px;">Sign in</h3>
    <div class="muted" style="margin:0 0 14px;">
      Please sign in to use FlockFlow.
    </div>

    <div class="gateGrid">
      <div>
        <div class="muted" style="font-size:12px; margin-bottom:6px;">Email</div>
        <input id="gateEmail" class="gateInput" type="email" autocomplete="username" placeholder="you@company.com" />
      </div>

      <div>
        <div class="muted" style="font-size:12px; margin-bottom:6px;">Password</div>
        <input id="gatePassword" class="gateInput" type="password" autocomplete="current-password" placeholder="••••••••" />
      </div>

      <button class="btn btnWide" id="btnGateSignIn">Sign In</button>
    </div>

    <div id="gateErr" class="muted" style="margin-top:10px; color:#b00020; display:none;"></div>
  </div>
</div>
<div class="wrap" id="appWrap">
  <div class="appHeader">
  <div>
    <h2 class="appTitle">FlockFlow</h2>
    <div class="appSubtitle">Online logging for eggs, mortality, and feed. Export CSV anytime.</div>
  </div>
<!-- Top-right user dropdown (this replaces the old "Signed in as") -->
  <div class="userMenu" id="userMenu">
    <details id="userDetails">
      <summary class="userPill" id="userPill">Not signed in</summary>
      <div class="userDropdown">
        <div class="muted" style="font-size:12px; margin-bottom:8px;">Account</div>
        <div id="userEmail" style="font-weight:700; margin-bottom:10px;">—</div>
        <button class="btn btnSmall danger" id="btnGlobalSignOut">Sign out</button>
      </div>
    </details>
  </div>
</div>
  <div class="nav">
    <button class="btn" id="tabEggs">Eggs</button>
    <button class="btn" id="tabMortality">Mortality</button>
    <button class="btn" id="tabFeed">Feed</button>
    <button class="btn" id="tabSummary">Summary</button>
    <button class="btn" id="tabAdmin" style="display:none;">Admin</button>
    <button class="btn modeBtn" id="toggleTheme" title="Toggle Light or Dark">Mode</button>
   <!-- Add this inside <div class="nav"> ... </div> -->

  </div>

  <div class="card cardPop">
    <div class="row">
      <div>
        <div class="muted">Date</div>
        <input id="date" type="date" />
      </div>

      <div>
        <div class="muted">Caretaker</div>
        <input id="caretaker" type="text" placeholder="Name" />
      </div>

      <div>
        <div class="muted">Round (Egg Collection)</div>
        <div class="big" id="round">1</div>
      </div>

      <div>
        <div class="muted">Admin</div>
        <div class="row" style="gap:8px;">
          <span class="pill" id="adminStatus">Locked</span>
          <button class="btn btnSmall" id="btnUnlock">Unlock</button>
          <button class="btn btnSmall" id="btnLock" style="display:none;">Lock</button>
        </div>
      </div>

      <div style="min-width:240px;">
        <div class="muted">Active Box</div>
        <div class="big" id="activeBox">(none)</div>
      </div>

      <div style="min-width:300px;">
        <div class="muted">Last Logged</div>
        <div class="kpi" id="lastLogged">—</div>
      </div>
    </div>
  </div>

  <!-- EGGS VIEW -->
  <div id="viewEggs">
    <div class="card cardPop">
      <h3 class="sectionTitle">Nest Eggs</h3>
      <div class="muted">Tap the box you are at, then tap holes (1–10).</div>

      <div class="twoCol" style="margin-top:12px;">
        <div class="card cardInner" style="margin:0;">
          <div class="houseLabel">Pen 1 (N01–N04)</div>
          <div class="boxGrid" id="pen1Boxes"></div>
        </div>

        <div class="card cardInner" style="margin:0;">
          <div class="houseLabel">Pen 2 (N05–N14)</div>
          <div class="boxGrid" id="pen2Boxes"></div>
        </div>

        <div class="card cardInner" style="margin:0;">
          <div class="houseLabel">Pen 4 (S01–S04)</div>
          <div class="boxGrid" id="pen4Boxes"></div>
        </div>

        <div class="card cardInner" style="margin:0;">
          <div class="houseLabel">Pen 3 (S05–S14)</div>
          <div class="boxGrid" id="pen3Boxes"></div>
        </div>
      </div>

      <h4 style="margin: 14px 0 8px;">Holes (1–10)</h4>
      <div class="holesGrid" id="holes"></div>

      <div class="row" style="margin-top:14px;">
        <button class="btn btnWide" id="clearBox">Clear Box</button>
        <button class="btn btnWide" id="nextRound">Next Round</button>
        <button class="btn btnWide" id="undoNest">Undo Nest</button>
      </div>
    </div>

    <div class="card cardPop">
      <h3 class="sectionTitle">Floor Eggs + Egg Defects</h3>
      <div class="muted">Select Pen, then tap buttons. Defects are a subset of total eggs.</div>

      <div class="row" style="gap:8px; margin-top:10px;">
        <button class="btn btnSmall" id="eggPen1">Pen 1</button>
        <button class="btn btnSmall" id="eggPen2">Pen 2</button>
        <button class="btn btnSmall" id="eggPen3">Pen 3</button>
        <button class="btn btnSmall" id="eggPen4">Pen 4</button>
      </div>

      <div class="twoCol" style="margin-top:12px;">
        <div class="card cardInner" style="margin:0;">
          <h4 class="sectionTitle">Floor Eggs</h4>
          <div class="row" style="margin-top:10px;">
            <button class="btn btnWide" id="floorPlus">+1 Floor Egg</button>
            <button class="btn btnWide" id="undoFloor">Undo Floor</button>
          </div>
        </div>

        <div class="card cardInner" style="margin:0;">
          <h4 class="sectionTitle">Defects</h4>
          <div class="row" style="margin-top:10px;">
            <button class="btn btnWide" id="defDirty">+1 Dirty</button>
            <button class="btn btnWide" id="defCrack">+1 Cracked</button>
          </div>
          <div class="row" style="margin-top:10px;">
            <button class="btn btnWide" id="defDouble">+1 Double</button>
            <button class="btn btnWide" id="defCull">+1 Cull</button>
          </div>
          <div class="row" style="margin-top:10px;">
            <button class="btn btnWide" id="undoDefect">Undo Defect</button>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h4 class="sectionTitle">Egg Totals (Selected Pen, Date, Current Round)</h4>
        <div class="row" style="margin-top:8px;">
          <div class="kpi">Nest: <span id="penNest">0</span></div>
          <div class="kpi">Floor: <span id="penFloor">0</span></div>
          <div class="kpi">Total: <span id="penTotalEggs">0</span></div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div class="kpi">Dirty: <span id="penDirty">0</span></div>
          <div class="kpi">Cracked: <span id="penCrack">0</span></div>
          <div class="kpi">Double: <span id="penDouble">0</span></div>
          <div class="kpi">Cull: <span id="penCull">0</span></div>
        </div>
      </div>
    </div>
  </div>

  <!-- MORTALITY VIEW -->
  <div id="viewMortality" style="display:none;">
    <div class="twoCol">
      <div class="card cardPop">
        <h3 class="sectionTitle">Mortality</h3>
        <div class="muted">Select a pen, then log dead or culled by sex.</div>

        <div class="row" style="gap:8px; margin-top:8px;">
          <button class="btn btnSmall" id="mortPen1">Pen 1</button>
          <button class="btn btnSmall" id="mortPen2">Pen 2</button>
          <button class="btn btnSmall" id="mortPen3">Pen 3</button>
          <button class="btn btnSmall" id="mortPen4">Pen 4</button>
          <button class="btn btnSmall" id="mortPen5">Spares (M)</button>
        </div>

        <div class="card" style="margin-top:12px;">
          <h4 class="sectionTitle">Log Mortality</h4>
          <div class="row" style="margin-top:8px;">
            <button class="btn btnWide" id="deadM">+1 Dead Male</button>
            <button class="btn btnWide" id="deadF">+1 Dead Female</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <button class="btn btnWide" id="cullM">+1 Culled Male</button>
            <button class="btn btnWide" id="cullF">+1 Culled Female</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <button class="btn btnWide" id="undoMort">Undo</button>
          </div>
        </div>
      </div>

      <div class="card cardPop">
        <h3 class="sectionTitle">Inventory and Totals</h3>
        <div class="muted">Inventory uses Birds Placed (Admin) minus cumulative mortality through selected Date.</div>

        <div class="card" style="margin-top:12px;">
          <h4 class="sectionTitle">Current Inventory (Selected Pen and Date)</h4>
          <div class="row">
            <div class="kpi">Male: <span id="invM">0</span></div>
            <div class="kpi">Female: <span id="invF">0</span></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h4 class="sectionTitle">Today’s Mortality Totals (Selected Pen and Date)</h4>
          <table>
            <thead>
              <tr>
                <th>Dead Male</th><th>Dead Female</th><th>Culled Male</th><th>Culled Female</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td id="dayDeadM">0</td><td id="dayDeadF">0</td><td id="dayCullM">0</td><td id="dayCullF">0</td>
              </tr>
            </tbody>
          </table>
        </div>

      </div>
    </div>
  </div>

  <!-- FEED VIEW -->
  <div id="viewFeed" style="display:none;">
    <div class="card cardPop">
      <h3 class="sectionTitle">Feed to Weigh (lb, rounded to nearest tenth)</h3>
      <div class="muted">Uses inventory at selected Date and the most recent feed rates on or before that date.</div>

      <div class="card" style="margin-top:12px;">
        <table>
          <thead>
            <tr>
              <th rowspan="2">Pen</th>
              <th colspan="3">Male</th>
              <th colspan="3">Female</th>
            </tr>
            <tr>
              <th>Inventory</th><th>Rate (lb per bird)</th><th>Feed (lb)</th>
              <th>Inventory</th><th>Rate (lb per bird)</th><th>Feed (lb)</th>
            </tr>
          </thead>
          <tbody id="feedTable"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- SUMMARY VIEW -->
  <div id="viewSummary" style="display:none;">
    <div class="card cardPop">
      <div class="row" style="justify-content:space-between;">
        <div>
          <h3 class="sectionTitle">Summary</h3>
          <div class="muted">Daily uses selected Date. Weekly uses the week containing selected Date.</div>
        </div>
        <div class="row">
          <button class="btn btnSmall" id="sumDaily">Daily</button>
          <button class="btn btnSmall" id="sumWeekly">Weekly</button>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h4 class="sectionTitle" id="sumEggTitle">Egg Summary</h4>
        <table>
          <thead>
            <tr>
              <th>Pen</th><th>Nest</th><th>Floor</th><th>Total Eggs</th>
              <th>Dirty</th><th>Cracked</th><th>Double</th><th>Cull</th>
            </tr>
          </thead>
          <tbody id="eggSummaryTable"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:12px;">
        <h4 class="sectionTitle" id="sumMortTitle">Mortality Summary</h4>
        <table>
          <thead>
            <tr><th>Pen</th><th>Dead Male</th><th>Dead Female</th><th>Culled Male</th><th>Culled Female</th></tr>
          </thead>
          <tbody id="mortSummaryTable"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:12px;">
        <h4 class="sectionTitle" id="sumFeedTitle">Feed Summary (computed)</h4>
        <div class="muted" style="margin-bottom:8px;">Weekly sums 7 days of computed feed, based on inventory and rates each day.</div>
        <table>
          <thead>
            <tr>
              <th rowspan="2">Pen</th>
              <th colspan="2">Male Feed (lb)</th>
              <th colspan="2">Female Feed (lb)</th>
              <th rowspan="2">Total Feed (lb)</th>
            </tr>
            <tr>
              <th>Amount</th><th>Rate source</th>
              <th>Amount</th><th>Rate source</th>
            </tr>
          </thead>
          <tbody id="feedSummaryTable"></tbody>
        </table>
      </div>
      </div>
    </div>
  </div>

  <!-- ADMIN VIEW -->
  <div id="viewAdmin" class="pageWrap" style="display:none;">

   <div class="card cardPop">
      <h3 class="sectionTitle">Admin</h3>
      <div class="muted">Edit birds placed, feed rates, and clear data.</div>

    <div class="card" style="margin-top:12px;">
      <h4 class="sectionTitle">Cloud Sync</h4>
      <div class="muted">Tablet can pull settings. Only signed-in admins can push changes.</div>
      <div class="row" style="margin-top:10px;">
        <button class="btn btnSmall" id="btnCloudPull">Sync From Cloud</button>
        <button class="btn btnSmall" id="btnFullHistorySync">Sync All History (90 days)</button>
      </div>
      <div class="row" style="margin-top:10px; align-items:flex-start;">
        <label class="row" style="gap:8px; cursor:pointer; user-select:none;">
          <input type="checkbox" id="togEventsAuto" />
          <div>
            <div style="font-weight:700;">Autosync Eggs + Mortality</div>
            <div class="muted" style="font-size:12px;">OFF = settings still autosync, but egg/mort events won’t pull/push automatically.</div>
          </div>
        </label>
        <div style="flex:1;"></div>
        <button class="btn btnSmall" id="btnMasterPushNow" title="Overwrite cloud egg/mort events with THIS device">Master Push (Overwrite Cloud)</button>
      </div>
      <div class="muted" style="margin-top:8px; font-size:12px;">
        Tip: If you turn Autosync ON, you’ll choose: Master autosync (push then pull), Normal autosync (pull then overwrite this device), or Cancel.
      </div>
    </div>

      <div class="card">
        <h4 class="sectionTitle">Birds Placed (management only)</h4>
        <table>
          <thead>
            <tr><th>Pen</th><th>Placed Male</th><th>Placed Female</th></tr>
          </thead>
          <tbody>
            <tr><td>Pen 1</td><td><input id="placed1M" type="number" step="1"></td><td><input id="placed1F" type="number" step="1"></td></tr>
            <tr><td>Pen 2</td><td><input id="placed2M" type="number" step="1"></td><td><input id="placed2F" type="number" step="1"></td></tr>
            <tr><td>Pen 3</td><td><input id="placed3M" type="number" step="1"></td><td><input id="placed3F" type="number" step="1"></td></tr>
            <tr><td>Pen 4</td><td><input id="placed4M" type="number" step="1"></td><td><input id="placed4F" type="number" step="1"></td></tr>
            <tr><td>Spares</td><td><input id="placed5M" type="number" step="1"></td><td><input id="placed5F" type="number" step="1" disabled></td></tr>
          </tbody>
        </table>
        <div class="row" style="margin-top:10px;">
          <button class="btn btnWide" id="savePlaced">Save Birds Placed</button>
        </div>
      </div>

      <div class="card">
        <h4 class="sectionTitle">Feed Rates (lb per bird per day)</h4>
        <div class="muted">Changes are logged with timestamp for history.</div>
        <table>
          <thead>
            <tr><th>Pen</th><th>Rate Male</th><th>Rate Female</th></tr>
          </thead>
          <tbody>
            <tr><td>Pen 1</td><td><input id="rate1M" type="number" step="0.001"></td><td><input id="rate1F" type="number" step="0.001"></td></tr>
            <tr><td>Pen 2</td><td><input id="rate2M" type="number" step="0.001"></td><td><input id="rate2F" type="number" step="0.001"></td></tr>
            <tr><td>Pen 3</td><td><input id="rate3M" type="number" step="0.001"></td><td><input id="rate3F" type="number" step="0.001"></td></tr>
            <tr><td>Pen 4</td><td><input id="rate4M" type="number" step="0.001"></td><td><input id="rate4F" type="number" step="0.001"></td></tr>
            <tr><td>Spares</td><td><input id="rate5M" type="number" step="0.001"></td><td><input id="rate5F" type="number" step="0.001" disabled></td></tr>
          </tbody>
        </table>
        <div class="row" style="margin-top:10px;">
          <button class="btn btnWide" id="saveRates">Save Feed Rates</button>
        </div>
      </div>
    
        <div class="card">
          <h4 class="sectionTitle">Exports</h4>
          <div class="row" style="margin-top:10px;">
            <button class="btn btnWide" id="exportDetail">Export Detail CSV</button>
            <button class="btn btnWide" id="exportSummary">Export Summary CSV</button>
          </div>
        </div>
        <div class="card">
        <h4 class="sectionTitle">Danger Zone</h4>
        <div class="row" style="margin-top:10px;">
          <button class="btn btnWide danger" id="clearAll">Clear ALL Data</button>
        </div>
      </div>
      <div class="card">
        <h4 class="sectionTitle">Change Admin PIN</h4>
        <div class="muted">Default PIN is 1234.</div>
        <div class="row" style="margin-top:10px;">
          <input id="newPin" type="password" placeholder="New PIN" />
          <button class="btn btnWide" id="savePin">Save PIN</button>
        </div>
      </div>

    </div>
  </div>

</div>

<div id="syncFooter" style="
  position:fixed; left:0; right:0; bottom:0;
  padding:8px 12px;
  background:rgba(0,0,0,0.06);
  font-size:12px;
  z-index:9999;">
  <span id="syncStatus">Last sync: never</span>
</div>

<script>
(() => {
  const STORAGE_KEY = "house_logger_v8_records";
  const STATE_KEY   = "house_logger_v8_state";
  const DEFAULT_PIN = "1234";
  const supabaseEnabled = true; // set false to disable cloud sync entirely
  // Autosync control for Egg + Mortality events
  let autosyncEventsEnabled = JSON.parse(localStorage.getItem("autosyncEventsEnabled") || "true");
  // Startup choice when turning autosync ON: "master" (push then pull), "normal" (pull then overwrite local), or "cancel"
  let eventsAutosyncStartupMode = localStorage.getItem("eventsAutosyncStartupMode") || "normal";
  const PENDING_EVENTS_KEY = "house_logger_v8_pending_events";
  let syncInFlight = false;
  let syncDebounceTimer = null;

  const LEGACY_KEYS = [
    { records: "house_logger_v7_records", state: "house_logger_v7_state" },
    { records: "house_logger_v6_records", state: "house_logger_v6_state" }
  ];

// =================== SUPABASE (SETTINGS SYNC ONLY) ===================
const SUPABASE_URL = "https://wdsdfsnozzfljjqydcgs.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indkc2Rmc25venpmbGpqcXlkY2dzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIxMzUxNDcsImV4cCI6MjA4NzcxMTE0N30.1wVMaytWX-vU3BmfYqZU-GlRICW9rntfDnJcWKP9q_w";
const SETTINGS_ROW_ID = "main";

// create ONE client and expose it globally
window.supabaseClient = window.supabase.createClient(
  SUPABASE_URL,
  SUPABASE_ANON_KEY
);
  // Cache session to avoid repeated getSession() calls (prevents auth lock races)
  let currentSession = null;
  window.supabaseClient.auth.onAuthStateChange((_event, session) => {
    currentSession = session || null;
    // keep UI updated
    setUserDisplay(currentSession);
    setUiSignedIn(!!currentSession);
    if (currentSession) {
      // run a sync shortly after auth is ready
      scheduleSync("login");
      startAutoSync();
    } else {
      stopAutoSync();
    }
  });

// Alias so older helpers that use `supabaseClient` still work
const supabaseClient = window.supabaseClient;
function setUserDisplay(session){
  const pill = document.getElementById("userPill");
  const emailEl = document.getElementById("userEmail");
  const details = document.getElementById("userDetails");

  if (!session) {
    if (pill) pill.textContent = "Not signed in";
    if (emailEl) emailEl.textContent = "—";
    if (details) details.open = false;
    return;
  }

  const email = session.user?.email || "Unknown user";
  if (pill) pill.textContent = email;
  if (emailEl) emailEl.textContent = email;
}
let lastSyncTimer = null;

function setSyncStatus(text){
  const el = document.getElementById("syncStatus");
  if (el) el.textContent = text;
}

function fmtTime(d = new Date()){
  const pad = (n)=> (n < 10 ? "0"+n : ""+n);
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
// =================== AUTH GATE (HIDE APP UNLESS SIGNED IN) ===================
function setUiSignedIn(isSignedIn){
  const app  = document.getElementById("appWrap");
  const gate = document.getElementById("loginGate");

  // Never let BOTH be hidden
  if (gate) gate.style.display = isSignedIn ? "none" : "flex";

  if (app) {
    // Keep app visible (so you can blur/see it behind the gate),
    // but disable interaction while signed out
    app.style.display = "block";
    app.style.pointerEvents = isSignedIn ? "auto" : "none";
    app.style.userSelect = isSignedIn ? "auto" : "none";
    app.style.filter = isSignedIn ? "none" : "blur(6px)";
    app.style.opacity = isSignedIn ? "1" : "0.9";
  }
}

// Runs on every page load
async function bootAuthAndAutoSync(){
  if (!supabaseEnabled || !window.supabaseClient) return;

  try {
    const { data } = await window.supabaseClient.auth.getSession();
    currentSession = data.session || null;

    setUserDisplay(currentSession);
    setUiSignedIn(!!currentSession);

    if (currentSession) {
      startAutoSync();
      // Immediately pull current week on boot so UI is populated
      const r = getSyncRange();
      await pullSettingsFromCloud();
      await pullEventsForRange(r.start, r.end);
      setSyncStatus(`Last sync: ${fmtTime()} (boot)`);
    } else {
      stopAutoSync();
    }
  } catch (e) {
    console.log("bootAuthAndAutoSync crashed:", e?.message || e);
  }
}


// React to sign-in / sign-out events
// Push ONE event. Return true if inserted, false if not.
async function pushEventToCloud(evt){
  try {
    if (!navigator.onLine) return false;
    if (!currentSession) return false;

    const payload = {
      event_uuid: evt.id,
      date: evt.date ?? null,
      caretaker: evt.caretaker ?? null,
      kind: evt.kind ?? null,
      pen: evt.pen ?? null,
      round: evt.round ?? null,
      box: evt.box ?? null,
      hole: evt.hole ?? null,
      defect_type: evt.defectType ?? null,
      action: evt.action ?? null,
      sex: evt.sex ?? null,
      value: evt.value ?? null,
      count: evt.count ?? 1,
      tsISO: evt.tsISO ?? null,
      tsLocal: evt.tsLocal ?? null
    };

    const { error } = await window.supabaseClient
      .from("house_events")
      .upsert([payload], { onConflict: "event_uuid" });

    if (error) {
      console.log("Cloud upsert failed:", error?.code, "|", error?.message, "|", error?.hint, "|", error?.details);
      return false;
    }
    return true;
  } catch (e) {
    console.log("Cloud upsert crashed:", e);
    return false;
  }
}

  // =================== PENDING UPLOAD QUEUE ===================
  function setPendingQueue(q){
  try {
    const capped = (q || []).slice(-10000); // keep last 10k events max
    localStorage.setItem(PENDING_EVENTS_KEY, JSON.stringify(capped));
  } catch {}
}
function getPendingQueue(){
  try { return JSON.parse(localStorage.getItem(PENDING_EVENTS_KEY) || "[]"); }
  catch { return []; }
}


function enqueueEventForCloud(evt){
  if (!evt) return;

  // Ensure stable id
  evt.id = evt.id || (crypto?.randomUUID ? crypto.randomUUID()
    : ("id_" + Date.now() + "_" + Math.random().toString(16).slice(2)));

  const q = getPendingQueue();

  // Deduplicate by id
  if (q.some(x => x && x.id === evt.id)) return;

  q.push(evt);
  setPendingQueue(q);
}

function removePendingById(id){
  if (!id) return;
  const q = getPendingQueue();
  setPendingQueue(q.filter(x => x && x.id !== id));
}

function pendingCount(){
  return getPendingQueue().length;
}
  function updatePendingBadge(){
    // optional: show pending count in sync footer
    const el = $("syncStatus");
    if (!el) return;
    const txt = el.textContent || "";
    const q = getPendingQueue();
    const cleaned = txt.replace(/\s*\(pending\s*\d+\)\s*$/, "");
    el.textContent = cleaned + (q.length ? ` (pending ${q.length})` : "");
  }
  async function flushPendingEventsToCloud(maxItems = 200){
  if (!supabaseEnabled) return;
  if (!window.supabaseClient) return;
  if (!navigator.onLine) return;
  if (!currentSession) return; // must be signed in to push

  let q = getPendingQueue();
  if (!q.length) { updatePendingBadge(); return; }

  // === HEAL: fix any events with non-UUID ids (e.g. old numeric or malformed ids) ===
  // These cause the bigint/text mismatch 400 error. Reassign them a proper UUID.
  let healed = false;
  const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  q = q.map(evt => {
    if (!evt) return evt;
    if (!evt.id || !uuidPattern.test(String(evt.id))) {
      evt.id = crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Date.now() + "_" + Math.random().toString(16).slice(2));
      healed = true;
    }
    return evt;
  });
  if (healed) setPendingQueue(q);

  const batch = q.slice(0, maxItems);

  // Build payloads (use event_uuid for dedupe — id column stays as bigint identity)
  const toInt = v => { const n = parseInt(v, 10); return Number.isFinite(n) ? n : null; };
  const toNum = v => { const n = parseFloat(v); return Number.isFinite(n) ? n : null; };
  const payloads = batch.map(evt => ({
    event_uuid: evt.id,  // app UUID → event_uuid column
    date: evt.date ?? null,
    caretaker: evt.caretaker ?? null,
    kind: evt.kind ?? null,
    pen: toInt(evt.pen),
    round: toInt(evt.round),
    box: evt.box ?? null,
    hole: toInt(evt.hole),
    defect_type: evt.defectType ?? null,
    action: evt.action ?? null,
    sex: evt.sex ?? null,
    value: toNum(evt.value),
    count: toInt(evt.count) ?? 1,
    tsISO: evt.tsISO ?? null,
    tsLocal: evt.tsLocal ?? null
  }));

  const { error } = await window.supabaseClient
    .from("house_events")
    .upsert(payloads, { onConflict: "event_uuid" });

  if (error) {
    console.log("Cloud upsert failed (flush):", error?.code, "|", error?.message, "|", error?.hint, "|", error?.details);
    updatePendingBadge();
    return;
  }

  // remove sent items
  const remaining = q.slice(batch.length);
  setPendingQueue(remaining);
  updatePendingBadge();

  // === localStorage size guard: warn if records are getting large ===
  try {
    const raw = localStorage.getItem(STORAGE_KEY) || "";
    const kb = Math.round(raw.length / 1024);
    if (kb > 3000) { // warn at 3MB (localStorage limit is ~5MB)
      console.warn(`FlockFlow: localStorage records is ${kb}KB — approaching limit.`);
      setSyncStatus(`Last sync: ${fmtTime()} ⚠️ Storage ${kb}KB (limit ~5000KB)`);
    }
  } catch {}
}

  function scheduleSync(reason="auto"){
    if (!supabaseEnabled) return;
    if (!window.supabaseClient) return;
    if (syncDebounceTimer) clearTimeout(syncDebounceTimer);
    syncDebounceTimer = setTimeout(() => {
      syncDebounceTimer = null;
      runSyncCycle(reason);
    }, 800);
  }
  async function runSyncCycle(reason="auto"){
    if (syncInFlight) return;
    if (!navigator.onLine) return;
    syncInFlight = true;
    try {
      // Flush any pending house_events queue (legacy backlog)
      const pending = getPendingQueue().length;
      if (pending > 0) {
        const batchSize = pending > 1000 ? 500 : pending > 200 ? 300 : 200;
        await flushPendingEventsToCloud(batchSize);
      }
      // Pull settings always
      await pullSettingsFromCloud();
      const r = getSyncRange();
      if (autosyncEventsEnabled) {
        await pullEventsForRange(r.start, r.end);
      }setSyncStatus(`Last sync: ${fmtTime()} (${reason})`);
      updatePendingBadge();
    } catch (e) {
      setSyncStatus(`Last sync: FAILED ${fmtTime()} (${reason})`);
    } finally {
      syncInFlight = false;
    }
  }

let _debuggedCols = false;
function normalizeCloudEvent(row){
  // One-time log to confirm exact column names returned by Supabase
  if (!_debuggedCols) {
    console.log("[Pull] Column names from Supabase:", Object.keys(row));
    _debuggedCols = true;
  }
  return {
    id: row.event_uuid ?? null,
    tsISO: row.tsISO ?? row.tsiso ?? null,
    tsLocal: row.tsLocal ?? row.tslocal ?? null,
    date: row.date,
    caretaker: row.caretaker,
    kind: row.kind,
    pen: row.pen,
    round: row.round,
    box: row.box,
    hole: row.hole,
    defectType: row.defect_type ?? null,
    action: row.action ?? null,
    sex: row.sex ?? null,
    value: row.value ?? null,
    count: row.count ?? 1
  };
}

function eventKey(e){
  // If the event has a stable UUID, use it alone — this prevents same-position eggs
  // from different devices being incorrectly collapsed into one record.
  if (e.id) return `uuid:${e.id}`;
  // Fallback for legacy records without an id: use field-based key
  return `${e.tsISO||""}|${e.kind||""}|${e.date||""}|${e.pen||""}|${e.round||""}|${e.box||""}|${e.hole||""}|${e.defectType||""}|${e.sex||""}|${e.action||""}|${e.value||""}`;
}

async function pullEventsFromCloud(startDate, endDate){
  try {
    if (!navigator.onLine) return;

    const { data: sess } = await window.supabaseClient.auth.getSession();
    if (!sess.session) throw new Error("Not signed in.");

    // Paginate to get ALL rows — Supabase default limit is 1000
    const PAGE_SIZE = 1000;
    let allRows = [];
    let page = 0;
    while (true) {
      const { data, error } = await window.supabaseClient
        .from("house_events")
        .select("*")
        .gte("date", startDate)
        .lte("date", endDate)
        .order("date", { ascending: true })
        .range(page * PAGE_SIZE, (page + 1) * PAGE_SIZE - 1);

      if (error) {
        console.log("Cloud events pull failed:", error.message);
        setSyncStatus(`Last sync: FAILED ${fmtTime()} (events pull)`);
        return;
      }

      allRows = allRows.concat(data || []);
      if (!data || data.length < PAGE_SIZE) break; // last page
      page++;
    }

    console.log(`[Pull] range ${startDate}→${endDate}, cloud returned ${allRows.length} rows, local records: ${records.length}`);

    const existingIds  = new Set(records.map(r => r.id).filter(Boolean));
    const existingKeys = new Set(records.map(eventKey));
    let added = 0, skippedId = 0, skippedKey = 0;

    for (const row of allRows){
      const evt = normalizeCloudEvent(row);

      if (evt.id && existingIds.has(evt.id)) { skippedId++; continue; }
      const k = eventKey(evt);
      if (existingKeys.has(k)) { skippedKey++; continue; }

      if (evt.id) existingIds.add(evt.id);
      existingKeys.add(k);
      records.push(evt);
      added++;
    }

    console.log(`[Pull] added: ${added}, skipped by id: ${skippedId}, skipped by key: ${skippedKey}`);

    if (added > 0) {
      saveRecords();
      updateEggPenKpis();
      refreshMortalityPanel();
      renderFeedTable();
      renderSummary();
    }

    setSyncStatus(`Last sync: ${fmtTime()} (events${added ? ` +${added}` : ""})`);
  } catch (e) {
    console.log("Cloud events pull crashed:", e.message);
    setSyncStatus(`Last sync: FAILED ${fmtTime()} (events crashed)`);
  }
}
// Make this return EXACTLY your local settings shape.
// You will edit this to match your current variables/objects.
function numVal(id) {
  const el = document.getElementById(id);
  if (!el) return 0;
  const n = parseFloat(el.value);
  return Number.isFinite(n) ? n : 0;
}

function getLocalSettingsObject() {
  const placed = {};
  const rates = {};

  for (let pen = 1; pen <= 5; pen++) {
    placed[String(pen)] = {
      m: numVal(`placed${pen}M`),
      f: (pen === 5) ? 0 : numVal(`placed${pen}F`)
    };

    rates[String(pen)] = {
      m: numVal(`rate${pen}M`),
      f: (pen === 5) ? 0 : numVal(`rate${pen}F`)
    };
  }

  return { placed, rates };
}
// Apply cloud settings into your local variables/objects.
// You will edit this to match your current variables/objects, then call your normal re-render functions.
function setVal(id, v) {
  const el = document.getElementById(id);
  if (!el) return;
  el.value = (v ?? 0);
}

function applySettingsObjectToLocal(obj) {
  if (!obj) return;

  for (let pen = 1; pen <= 5; pen++) {
    const p = obj.placed?.[String(pen)] || {};
    const r = obj.rates?.[String(pen)] || {};

    setVal(`placed${pen}M`, p.m ?? 0);
    if (pen !== 5) setVal(`placed${pen}F`, p.f ?? 0);

    setVal(`rate${pen}M`, r.m ?? 0);
    if (pen !== 5) setVal(`rate${pen}F`, r.f ?? 0);
  }

  // Then run your existing refresh function(s) if they exist
  if (typeof loadAdminInputs === "function") loadAdminInputs();
}
function applyCloudSettingsToLocal(settings) {
  // settings = { placed: { "1":{m,f}... }, rates: { "1":{m,f}... } }
  // Write directly to the event log WITHOUT triggering cloud re-queue.
  // Only add a settings event if the value differs from the most recent one already stored.

  function getLastSettingValue(kind, pen, sex) {
    // Find the most recently logged value for this setting
    for (let i = records.length - 1; i >= 0; i--) {
      const r = records[i];
      if (r.kind === kind && r.pen === pen && r.sex === sex) return r.value;
    }
    return null;
  }

  function addSettingIfChanged(kind, pen, sex, newVal) {
    const current = getLastSettingValue(kind, pen, sex);
    if (current === newVal) return; // already up to date, skip
    const evt = { ...baseMeta(), kind, pen, sex, value: newVal };
    evt.id = crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Date.now() + "_" + Math.random().toString(16).slice(2));
    records.push(evt);
  }

  for (let pen = 1; pen <= 5; pen++) {
    const p = (settings.placed && settings.placed[String(pen)]) ? settings.placed[String(pen)] : { m: 0, f: 0 };
    const r = (settings.rates  && settings.rates[String(pen)])  ? settings.rates[String(pen)]  : { m: 0, f: 0 };

    addSettingIfChanged("placed", pen, "M", p.m ?? 0);
    if (pen !== 5) addSettingIfChanged("placed", pen, "F", p.f ?? 0);
    addSettingIfChanged("rate", pen, "M", r.m ?? 0);
    if (pen !== 5) addSettingIfChanged("rate", pen, "F", r.f ?? 0);
  }

  saveRecords();

  // Refresh admin UI + any computed tables
  if (typeof loadAdminInputs === "function") loadAdminInputs();
  if (typeof rebuildFeedTable === "function") rebuildFeedTable();
  if (typeof refreshAll === "function") refreshAll();
}
// =================== EVENTS SYNC (same pattern as settings) ===================
// Push today's events as a JSON blob to app_settings, keyed by date.
// This is identical to how pushSettingsToCloud works — proven reliable.
async function ensureEventId(evt){
  if (!evt.id) {
    evt.id = (crypto?.randomUUID)
      ? crypto.randomUUID()
      : ("id_" + Date.now() + "_" + Math.random().toString(16).slice(2));
  }
  return evt;
}

// NORMAL background push should MERGE with cloud to avoid overwriting other devices.
async function pushEventsForDateMerge(dateStr){
  try {
    if (!window.supabaseClient || !navigator.onLine) return;
    const { data: sess } = await window.supabaseClient.auth.getSession();
    if (!sess.session) return;

    const rowId = `events_${dateStr}`;

    const localDayEvents = records
      .filter(r => ["egg_nest","egg_floor","egg_defect","mort"].includes(r.kind))
      .filter(r => r.date === dateStr)
      .map(e => ensureEventId(e));

    // Pull existing cloud day
    const { data: existingRow, error: readErr } = await window.supabaseClient
      .from("app_settings")
      .select("data")
      .eq("id", rowId)
      .maybeSingle();

    if (readErr) {
      console.log("pushEventsForDateMerge read failed:", readErr.code, "|", readErr.message);
    }

    const cloudEvents = existingRow?.data?.events || [];

    // Merge by id (union)
    const mergedById = new Map();
    for (const e of cloudEvents) if (e?.id) mergedById.set(e.id, e);
    for (const eP of localDayEvents) {
      const e = (eP instanceof Promise) ? await eP : eP;
      if (e?.id) mergedById.set(e.id, e);
    }

    const mergedEvents = Array.from(mergedById.values())
      .sort((a,b) => String(a.tsISO||"").localeCompare(String(b.tsISO||"")));

    const { data, error } = await window.supabaseClient
      .from("app_settings")
      .upsert({ id: rowId, data: { events: mergedEvents, date: dateStr } }, { onConflict: "id" })
      .select("id");

    if (error) {
      console.log("pushEventsForDateMerge failed:", error.code, "|", error.message, "|", error.hint);
    } else {
      console.log(`[Push] merged ${mergedEvents.length} events for ${dateStr} → cloud OK`, data);
    }
  } catch (e) {
    console.log("pushEventsForDateMerge crashed:", e.message);
  }
}

// MASTER overwrite push (explicit) – replaces cloud with THIS device’s day events.
async function pushEventsForDateOverwrite(dateStr){
  try {
    if (!window.supabaseClient || !navigator.onLine) return;
    const { data: sess } = await window.supabaseClient.auth.getSession();
    if (!sess.session) { alert("Not signed in."); return; }

    const dayEvents = records
      .filter(r => ["egg_nest","egg_floor","egg_defect","mort"].includes(r.kind))
      .filter(r => r.date === dateStr);

    dayEvents.forEach(e => ensureEventId(e));

    const rowId = `events_${dateStr}`;
    const { data, error } = await window.supabaseClient
      .from("app_settings")
      .upsert({ id: rowId, data: { events: dayEvents, date: dateStr } }, { onConflict: "id" })
      .select("id");

    if (error) {
      console.log("pushEventsForDateOverwrite failed:", error.code, "|", error.message, "|", error.hint);
    } else {
      console.log(`[MasterPush] overwrote ${dayEvents.length} events for ${dateStr} → cloud OK`, data);
    }
  } catch(e) {
    console.log("pushEventsForDateOverwrite crashed:", e.message);
  }
}

// Keep existing call-sites working:
async function pushEventsForDate(dateStr){
  return pushEventsForDateMerge(dateStr);
}

// Pull events for a date range from app_settings blobs and merge into records.
async function pullEventsForRange(startDate, endDate){
  try {
    if (!window.supabaseClient || !navigator.onLine) return;
    const { data: sess } = await window.supabaseClient.auth.getSession();
    if (!sess.session) return;

    console.log(`[Pull] querying events from ${startDate} to ${endDate}`);

    // Use like + filter instead of .in() with a long ID list
    const { data, error } = await window.supabaseClient
      .from("app_settings")
      .select("id, data")
      .like("id", "events_%")
      .gte("id", `events_${startDate}`)
      .lte("id", `events_${endDate}`);

    if (error) {
      console.log("pullEventsForRange failed:", error.message);
      setSyncStatus(`Last sync: FAILED ${fmtTime()} (events pull)`);
      return;
    }

    const existingIds = new Set(records.map(r => r.id).filter(Boolean));
    let added = 0;

    for (const row of (data || [])) {
      const evts = row.data?.events || [];
      for (const evt of evts) {
        if (evt.id && existingIds.has(evt.id)) continue;
        if (evt.id) existingIds.add(evt.id);
        records.push(evt);
        added++;
      }
    }

    console.log(`[Pull] ${startDate}→${endDate}: fetched ${(data||[]).length} day-rows, added ${added} events`);

    if (added > 0) {
      saveRecords();
      updateEggPenKpis();
      refreshMortalityPanel();
      renderFeedTable();
      renderSummary();
    }

    setSyncStatus(`Last sync: ${fmtTime()} (events${added ? ` +${added}` : ""})`);
  } catch(e) {
    console.log("pullEventsForRange crashed:", e.message);
    setSyncStatus(`Last sync: FAILED ${fmtTime()} (events crashed)`);
  }
}

// Normal pull merges into local. Sometimes you want the cloud to become the source of truth on this device.
async function pullEventsForRangeOverwriteLocal(startISO, endISO){
  // Remove local egg/mort events in range first, then pull and add cloud events back
  const startD = new Date(startISO + "T00:00:00");
  const endD   = new Date(endISO   + "T00:00:00");
  records = records.filter(r => {
    if (!["egg_nest","egg_floor","egg_defect","mort"].includes(r.kind)) return true;
    if (!r.date) return true;
    const d = new Date(r.date + "T00:00:00");
    return (d < startD || d > endD);
  });
  persistState();
  await pullEventsForRange(startISO, endISO);
}
// Pull latest settings from cloud
async function pullSettingsFromCloud(){
  try {
    const { data: sess } = await window.supabaseClient.auth.getSession();
    if (!sess.session) { throw new Error("Not signed in."); }
    const { data: row, error } = await window.supabaseClient
      .from("app_settings")
      .select("data, updated_at")
      .eq("id", "main")
      .maybeSingle();

    if (error) { setSyncStatus(`Last sync: FAILED ${fmtTime()} (settings pull)`); return; }
    if (!row)  { setSyncStatus(`Last sync: FAILED ${fmtTime()} (no settings row)`); return; }

    setSyncStatus(`Last sync: ${fmtTime()} (settings)`);

    // Apply cloud settings to this device
    applyCloudSettingsToLocal(row.data);

  } catch (e) {
    setSyncStatus(`Last sync: FAILED ${fmtTime()} (settings crashed)`);
  }
}
function stopAutoSync(){
  if (lastSyncTimer) {
    clearInterval(lastSyncTimer);
    lastSyncTimer = null;
  }
}

function getSyncRange(){
  const d = dateEl?.value || todayStr;
  // Pull selected week ± 1 week buffer for routine sync
  const start = addDays(startOfWeek(d), -7);
  const end = addDays(startOfWeek(d), 13);
  return { start, end };
}

function startAutoSync(){
  stopAutoSync();
  if (!supabaseEnabled) return;
  // run once now
  scheduleSync("auto");
  // Adaptive interval: 10s while pending events exist, 60s when caught up
  lastSyncTimer = setInterval(() => {
    if (!navigator.onLine) return;
    scheduleSync("auto");
  }, 10000);
}
// Push current settings to cloud (requires login)
async function pushSettingsToCloud(){
  try {
    if (!window.supabaseClient) return;
    if (!navigator.onLine) return;

    const { data: sess } = await window.supabaseClient.auth.getSession();
    if (!sess.session) { alert("Not signed in to Supabase."); return; }

    const payload = getLocalSettingsObject();

    const { data, error } = await window.supabaseClient
      .from("app_settings")
      .update({ data: payload })
      .eq("id", "main")
      .select("id, updated_at");

    if (error) { alert("Cloud push failed:\n" + error.message); return; }
    if (!data || data.length !== 1) { alert("Cloud push: updated 0 rows."); return; }

    // optional: nice confirmation
    // alert("Cloud push OK ✅");
  } catch (e) {
    alert("Cloud push crashed:\n" + e.message);
  }
}
async function sbSignIn() {
  const emailEl = document.getElementById("gateEmail");
  const passEl  = document.getElementById("gatePassword");
  const errEl   = document.getElementById("gateErr");

  const email = (emailEl?.value || "").trim();
  const password = passEl?.value || "";

  if (errEl) { errEl.style.display = "none"; errEl.textContent = ""; }

  if (!email || !password) {
    if (errEl) {
      errEl.textContent = "Enter both email and password.";
      errEl.style.display = "block";
    }
    return;
  }

  const { error } = await window.supabaseClient.auth.signInWithPassword({ email, password });

  if (error) {
    if (errEl) {
      errEl.textContent = error.message || "Sign in failed.";
      errEl.style.display = "block";
    }
    setSyncStatus(`Signed in: FAILED ${fmtTime()}`);
    return;
  }

  setSyncStatus(`Signed in: OK ${fmtTime()}`);
  if (passEl) passEl.value = "";
  startAutoSync();
}

async function sbSignOut() {
  try {
    const { error } = await window.supabaseClient.auth.signOut();
    if (error) throw error;
  } catch (e) {
    console.log("Sign out failed:", e?.message || e);
  }

  // Force local UI state immediately (don’t rely only on onAuthStateChange)
  stopAutoSync();
  setSyncStatus(`Signed out ${fmtTime()}`);
  setUserDisplay(null);
  setUiSignedIn(false);

  // Debug proof:
  const { data } = await window.supabaseClient.auth.getSession();
  console.log("Session after signOut:", data.session);
}




// ====================================================================

  const $ = (id) => document.getElementById(id);

  const pad2 = (n)=> (n<10?("0"+n):(""+n));
  const today = new Date();
  const todayStr = `${today.getFullYear()}-${pad2(today.getMonth()+1)}-${pad2(today.getDate())}`;

  function loadJSON(k, fallback){
    try { return JSON.parse(localStorage.getItem(k) || JSON.stringify(fallback)); }
    catch { return fallback; }
  }
  function saveJSON(k, v){ localStorage.setItem(k, JSON.stringify(v)); }

  function safeNum(x, fallback=0){
    const n = Number(x);
    return Number.isFinite(n) ? n : fallback;
  }

  function migrateIfEmpty(){
    // hide app until auth check completes
    bootAuthAndAutoSync();
    const existing = loadJSON(STORAGE_KEY, []);
    if (existing.length > 0) return;

    let merged = [];
    let mergedState = null;

    for (const lk of LEGACY_KEYS){
      const r = loadJSON(lk.records, []);
      if (Array.isArray(r) && r.length) merged = merged.concat(r);

      const s = loadJSON(lk.state, null);
      if (s && !mergedState) mergedState = s;
    }

    if (merged.length){
      // De-dupe by a soft key
      const seen = new Set();
      const out = [];
      for (const e of merged){
        const key = `${e.tsISO||""}|${e.kind||""}|${e.date||""}|${e.pen||""}|${e.box||""}|${e.hole||""}|${e.defectType||""}|${e.sex||""}|${e.action||""}|${e.value||""}`;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(e);
      }
      saveJSON(STORAGE_KEY, out);
    }

    if (mergedState){
      const st = loadJSON(STATE_KEY, {});
      if (!Object.keys(st).length) saveJSON(STATE_KEY, mergedState);
    }
  }

  migrateIfEmpty();

  // If localStorage cache is oversized (>3MB), clear it — cloud will repopulate
  try {
    const raw = localStorage.getItem(STORAGE_KEY) || "";
    if (raw.length > 3 * 1024 * 1024) {
      console.warn("Clearing oversized localStorage cache — cloud is source of truth");
      localStorage.removeItem(STORAGE_KEY);
    }
  } catch(e) {}

  let records = loadJSON(STORAGE_KEY, []);
  let state   = loadJSON(STATE_KEY, {});

  // Theme
  let theme = state.theme || "light";
  function applyTheme(){
    document.documentElement.setAttribute("data-theme", theme);
    $("toggleTheme").textContent = (theme === "dark") ? "Light Mode" : "Dark Mode";
  }

  function nowISO(){ return new Date().toISOString(); }
  function localTS(){
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
  }

  const dateEl = $("date");
  const caretakerEl = $("caretaker");
  const roundEl = $("round");
  const activeBoxEl = $("activeBox");
  const lastLoggedEl = $("lastLogged");

  dateEl.value = state.date || todayStr;
  caretakerEl.value = state.caretaker || "";

  let activeBox = state.activeBox || "";
  let round = Number.isFinite(state.round) ? state.round : 1;
  let eggPen = Number.isFinite(state.eggPen) ? state.eggPen : 1;

  let mortPen = Number.isFinite(state.mortPen) ? state.mortPen : 1;

  let adminUnlocked = !!state.adminUnlocked;
  let adminPin = state.adminPin || DEFAULT_PIN;

  function persistState(){
    saveJSON(STATE_KEY, {
      date: dateEl.value,
      caretaker: caretakerEl.value,
      activeBox, round, eggPen, mortPen,
      adminUnlocked, adminPin,
      theme
    });
  }
  // records = full in-memory dataset (lives in RAM)
  // localStorage only caches today's events + settings events as a safety net.
  // Everything else is pulled fresh from the cloud on boot.
  function saveRecords(){
    try {
      const today = dateEl?.value || todayStr;
      const toCache = records.filter(r =>
        r.kind === "placed" || r.kind === "rate" || r.date === today
      );
      saveJSON(STORAGE_KEY, toCache);
    } catch(e) {
      // If even that's too large, just clear old cache — cloud has the data
      try {
        localStorage.removeItem(STORAGE_KEY);
        console.warn("saveRecords: cleared localStorage cache — cloud is source of truth");
      } catch(e2) {}
    }
  }

  function baseMeta(){
    return {
      tsISO: nowISO(),
      tsLocal: localTS(),
      date: dateEl.value || todayStr,
      caretaker: (caretakerEl.value.trim() || "Unknown")
    };
  }

  // Tabs
  const tabs = [
    ["tabEggs","viewEggs"],
    ["tabMortality","viewMortality"],
    ["tabFeed","viewFeed"],
    ["tabSummary","viewSummary"],
    ["tabAdmin","viewAdmin"]
  ];

  function showTab(tabId){
    for (const [t,v] of tabs){
      $(v).style.display = (t===tabId) ? "block" : "none";
      $(t).classList.toggle("selectedBlue", t===tabId);
    }
    // Refresh tables when you visit
    if (tabId === "tabFeed") renderFeedTable();
    if (tabId === "tabSummary") renderSummary();
    if (tabId === "tabMortality") refreshMortalityPanel();
  }

  $("tabEggs").onclick = ()=>showTab("tabEggs");
  $("tabMortality").onclick = ()=>showTab("tabMortality");
  $("tabFeed").onclick = ()=>showTab("tabFeed");
  $("tabSummary").onclick = ()=>showTab("tabSummary");
  $("tabAdmin").onclick = ()=>showTab("tabAdmin");
  $("btnGateSignIn").onclick = sbSignIn;
document.getElementById("gatePassword")?.addEventListener("keydown", (e) => {
  if (e.key === "Enter") sbSignIn();
});
  // Cloud sync button
const btnCloudPull = document.getElementById("btnCloudPull");
if (btnCloudPull) {
  btnCloudPull.onclick = async () => {
    setSyncStatus(`Syncing... ${fmtTime()}`);
    await pullSettingsFromCloud();
  };
}
// Global user dropdown sign-out
const btnGlobalSignOut = document.getElementById("btnGlobalSignOut");
if (btnGlobalSignOut) {
  btnGlobalSignOut.onclick = async () => {
    await sbSignOut();
  };
}
  $("toggleTheme").onclick = ()=>{
    theme = (theme === "dark") ? "light" : "dark";
    applyTheme();
    persistState();
  };

  // Admin lock
  function refreshAdmin(){
    const st = $("adminStatus");
    if (adminUnlocked){
      st.textContent = "Unlocked";
      st.classList.add("ok");
      $("btnUnlock").style.display="none";
      $("btnLock").style.display="inline-block";
      $("tabAdmin").style.display="inline-block";
    } else {
      st.textContent = "Locked";
      st.classList.remove("ok");
      $("btnUnlock").style.display="inline-block";
      $("btnLock").style.display="none";
      $("tabAdmin").style.display="none";
      if ($("viewAdmin").style.display==="block") showTab("tabEggs");
    }
  }
  $("btnUnlock").onclick = () => {
    const entered = prompt("Enter Admin PIN:");
    if (entered === null) return;
    if (String(entered) === String(adminPin)){
      adminUnlocked = true;
      persistState();
      refreshAdmin();
      showTab("tabAdmin");
      loadAdminInputs();
    } else {
      alert("Incorrect PIN.\nPlease contact administrator for assistance.");
    }
  };
  $("btnLock").onclick = () => {
    adminUnlocked = false;
    persistState();
    refreshAdmin();
    showTab("tabEggs");
  };

  // Helpers
  function dateToInt(d){ return Number(String(d).replaceAll("-","")); }
  function inRangeDate(d, start, end){
    const x = dateToInt(d);
    return x >= dateToInt(start) && x <= dateToInt(end);
  }
  function startOfWeek(dateStr){
    // Monday as start
    const d = new Date(dateStr+"T00:00:00");
    const day = d.getDay(); // 0=Sun
    const diff = (day === 0 ? -6 : 1 - day);
    d.setDate(d.getDate() + diff);
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }
  function addDays(dateStr, delta){
    const d = new Date(dateStr+"T00:00:00");
    d.setDate(d.getDate() + delta);
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }

  // Pens and boxes mapping
  function penFromBoxId(boxId){
    const side = boxId.charAt(0);
    const num = Number(boxId.slice(1));
    if (side === "N") return (num <= 4) ? 1 : 2;
    if (side === "S") return (num <= 4) ? 4 : 3;
    return 0;
  }

  // Records logging wrapper
  function logEvent(evt, label){
    evt.id = evt.id || (crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Date.now() + "_" + Math.random().toString(16).slice(2)));
    records.push(evt);
    saveRecords();
    lastLoggedEl.textContent = label;
    persistState();

    // Push the full day's events as a blob — same pattern as savePlaced
    const evtDate = evt.date || todayStr;
    if (supabaseEnabled && navigator.onLine && currentSession) {
      pushEventsForDate(evtDate).catch(() => {});
    }

    // refresh views
    updateEggPenKpis();
    refreshMortalityPanel();
    renderFeedTable();
    renderSummary();
  }

  function undoLast(filterFn, label){
    for (let i=records.length-1;i>=0;i--){
      if (filterFn(records[i])){
        const removed = records[i];
        records.splice(i,1);
        saveRecords();
        lastLoggedEl.textContent = `Undone (${label})`;
        updateEggPenKpis();
        refreshMortalityPanel();
        renderFeedTable();
        renderSummary();

        // Re-push the day's blob with the event removed
        if (supabaseEnabled && navigator.onLine && currentSession) {
          pushEventsForDate(removed.date || todayStr).catch(() => {});
        }
        // Also clean up legacy queue if present
        if (removed.id) removePendingById(removed.id);
        return;
      }
    }
    lastLoggedEl.textContent = `Nothing to undo (${label})`;
  }

  // Eggs: boxes + holes rendering (the reliable fix)
  const boxButtons = {};
  function setActiveBox(boxId){
    activeBox = boxId;
    activeBoxEl.textContent = activeBox || "(none)";
    for (const k in boxButtons) boxButtons[k].classList.remove("selectedBlue");
    if (activeBox && boxButtons[activeBox]) boxButtons[activeBox].classList.add("selectedBlue");
    persistState();
  }
  function createBoxButton(id, parent){
    const b = document.createElement("button");
    b.className = "btn btnSmall boxBtn";
    b.textContent = id;
    b.onclick = ()=> setActiveBox(id);
    parent.appendChild(b);
    boxButtons[id] = b;
  }
  function renderBoxes(){
    const pen1 = $("pen1Boxes"), pen2 = $("pen2Boxes"), pen3 = $("pen3Boxes"), pen4 = $("pen4Boxes");
    pen1.innerHTML = ""; pen2.innerHTML = ""; pen3.innerHTML = ""; pen4.innerHTML = "";
    for (let i=1;i<=4;i++) createBoxButton(`N${pad2(i)}`, pen1);
    for (let i=5;i<=14;i++) createBoxButton(`N${pad2(i)}`, pen2);
    for (let i=1;i<=4;i++) createBoxButton(`S${pad2(i)}`, pen4);
    for (let i=5;i<=14;i++) createBoxButton(`S${pad2(i)}`, pen3);
  }

  function logNestEgg(hole){
    if (!activeBox){ alert("Tap a box first."); return; }
    const pen = penFromBoxId(activeBox);
    const nestId = `${activeBox}${hole}`;
    const evt = { ...baseMeta(), kind:"egg_nest", round, pen, box:activeBox, hole, nestId, count:1 };
    logEvent(evt, `Nest ${nestId} @ ${evt.tsLocal.split(" ")[1]}`);
  }

  function renderHoles(){
    const holesDiv = $("holes");
    holesDiv.innerHTML = "";
    for (let i=1;i<=10;i++){
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = String(i);
      b.onclick = ()=> logNestEgg(i);
      holesDiv.appendChild(b);
    }
  }

  // Egg pen selector
  const eggBtns = [ $("eggPen1"), $("eggPen2"), $("eggPen3"), $("eggPen4") ];
  function setEggPen(p){
    eggPen = p;
    eggBtns.forEach((b, idx)=> b.classList.toggle("selectedBlue", idx+1===p));
    persistState();
    updateEggPenKpis();
  }
  eggBtns.forEach((b, idx)=> b.onclick = ()=> setEggPen(idx+1));

  function logFloorEgg(){
    const m = baseMeta();
    logEvent({ ...m, kind:"egg_floor", round, pen:eggPen, count:1 });
  }

  function logDefect(defectType){
    const m = baseMeta();
    logEvent({ ...m, kind:"egg_defect", round, pen:eggPen, defectType, count:1 });
  }
  function eggTotalsForPen(dateStr, roundNum, pen){
    let nest=0,floor=0,dirty=0,crack=0,dbl=0,cull=0;
    let debugSample = null;
    for (const r of records){
      if (r.kind === "egg_nest" && r.date === dateStr && !debugSample) {
        debugSample = { pen: r.pen, penType: typeof r.pen, round: r.round, roundType: typeof r.round };
      }
      if (r.date!==dateStr) continue;
      if (r.round!==roundNum) continue;
      if (r.pen!==pen) continue;
      if (r.kind==="egg_nest") nest++;
      if (r.kind==="egg_floor") floor++;
      if (r.kind==="egg_defect"){
        if (r.defectType==="Dirty") dirty++;
        if (r.defectType==="Cracked") crack++;
        if (r.defectType==="Double") dbl++;
        if (r.defectType==="Cull") cull++;
      }
    }
    if (debugSample) console.log(`[eggTotals] date=${dateStr} roundNum=${roundNum}(${typeof roundNum}) pen=${pen}(${typeof pen}) | sample record:`, debugSample, `| nest=${nest}`);
    return {nest,floor,total:nest+floor,dirty,crack,dbl,cull};
  }

  function updateEggPenKpis(){
    const d = dateEl.value || todayStr;
    const t = eggTotalsForPen(d, round, eggPen);
    $("penNest").textContent = t.nest;
    $("penFloor").textContent = t.floor;
    $("penTotalEggs").textContent = t.total;
    $("penDirty").textContent = t.dirty;
    $("penCrack").textContent = t.crack;
    $("penDouble").textContent = t.dbl;
    $("penCull").textContent = t.cull;
  }

  $("clearBox").onclick = ()=> setActiveBox("");
  $("nextRound").onclick = ()=> { round += 1; roundEl.textContent=String(round); persistState(); updateEggPenKpis(); };
  $("undoNest").onclick = ()=> {
    const d = dateEl.value || todayStr;
    undoLast(r => r.kind==="egg_nest" && r.date===d && r.round===round, "Nest");
  };

  $("floorPlus").onclick = logFloorEgg;
  $("undoFloor").onclick = ()=> {
    const d = dateEl.value || todayStr;
    undoLast(r => r.kind==="egg_floor" && r.date===d && r.round===round && r.pen===eggPen, "Floor");
  };

  $("defDirty").onclick  = ()=> logDefect("Dirty");
  $("defCrack").onclick  = ()=> logDefect("Cracked");
  $("defDouble").onclick = ()=> logDefect("Double");
  $("defCull").onclick   = ()=> logDefect("Cull");
  $("undoDefect").onclick = ()=> {
    const d = dateEl.value || todayStr;
    undoLast(r => r.kind==="egg_defect" && r.date===d && r.round===round && r.pen===eggPen, "Defect");
  };

  // Mortality
  const mortBtns = [ $("mortPen1"), $("mortPen2"), $("mortPen3"), $("mortPen4"), $("mortPen5") ];
  function setMortPen(p){
    mortPen = p;
    mortBtns.forEach((b, idx)=> b.classList.toggle("selectedBlue", idx+1===p));
    persistState();
    refreshMortalityPanel();
  }
  mortBtns.forEach((b, idx)=> b.onclick = ()=> setMortPen(idx+1));

  function logMort(action, sex){
    const m = baseMeta();
    // action: "dead" | "cull"
    const evt = { ...m, kind:"mort", pen: mortPen, action, sex, count:1 };
    logEvent(evt, `${action.toUpperCase()} ${sex} Pen ${mortPen} @ ${m.tsLocal.split(" ")[1]}`);
  }

  $("deadM").onclick = ()=> logMort("dead","M");
  $("deadF").onclick = ()=> logMort("dead","F");
  $("cullM").onclick = ()=> logMort("cull","M");
  $("cullF").onclick = ()=> logMort("cull","F");
  $("undoMort").onclick = ()=> {
    const d = dateEl.value || todayStr;
    undoLast(r => r.kind==="mort" && r.date===d && r.pen===mortPen, "Mortality");
  };

  function sumMortalityFor(pen, startDate, endDate){
    let deadM=0,deadF=0,cullM=0,cullF=0;
    for (const r of records){
      if (r.kind !== "mort") continue;
      if (r.pen !== pen) continue;
      if (!inRangeDate(r.date, startDate, endDate)) continue;
      if (r.action==="dead" && r.sex==="M") deadM += 1;
      if (r.action==="dead" && r.sex==="F") deadF += 1;
      if (r.action==="cull" && r.sex==="M") cullM += 1;
      if (r.action==="cull" && r.sex==="F") cullF += 1;
    }
    return {deadM,deadF,cullM,cullF};
  }

  // Admin: placed + rates stored as records for history
  function getLatestSetting(kind, pen, sex, onOrBeforeDateStr){
    // kind: "placed" | "rate"
    // if onOrBeforeDateStr provided, find latest record with date <= it.
    // else latest overall.
    let best = null;
    for (const r of records){
      if (r.kind !== kind) continue;
      if (r.pen !== pen) continue;
      if (r.sex !== sex) continue;
      if (onOrBeforeDateStr && dateToInt(r.date) > dateToInt(onOrBeforeDateStr)) continue;
      if (!best) best = r;
      else if (dateToInt(r.date) > dateToInt(best.date)) best = r;
      else if (dateToInt(r.date) === dateToInt(best.date) && (r.tsISO||"") > (best.tsISO||"")) best = r;
    }
    return best ? safeNum(best.value, 0) : 0;
  }

  function getPlaced(pen, sex, onOrBeforeDateStr){
    return getLatestSetting("placed", pen, sex, onOrBeforeDateStr);
  }
  function getRate(pen, sex, onOrBeforeDateStr){
    return getLatestSetting("rate", pen, sex, onOrBeforeDateStr);
  }

  function getInventory(pen, sex, onOrBeforeDateStr){
    const placed = getPlaced(pen, sex, onOrBeforeDateStr);
    let losses = 0;
    for (const r of records){
      if (r.kind !== "mort") continue;
      if (r.pen !== pen) continue;
      if (r.sex !== sex) continue;
      if (dateToInt(r.date) > dateToInt(onOrBeforeDateStr)) continue;
      losses += 1;
    }
    const inv = placed - losses;
    return (inv < 0) ? 0 : inv;
  }

  function refreshMortalityPanel(){
    const d = dateEl.value || todayStr;

    // Today's totals for selected pen
    const day = sumMortalityFor(mortPen, d, d);
    $("dayDeadM").textContent = day.deadM;
    $("dayDeadF").textContent = day.deadF;
    $("dayCullM").textContent = day.cullM;
    $("dayCullF").textContent = day.cullF;

    // Inventory
    const invM = getInventory(mortPen, "M", d);
    const invF = (mortPen === 5) ? 0 : getInventory(mortPen, "F", d);

    $("invM").textContent = invM;
    $("invF").textContent = invF;
  }

  // Feed table
  function round1(x){ return Math.round(x * 10) / 10; }

  function renderFeedTable(){
    const tbody = $("feedTable");
    if (!tbody) return;
    const d = dateEl.value || todayStr;
    const rows = [];

    for (let pen=1; pen<=5; pen++){
      const invM = getInventory(pen, "M", d);
      const invF = (pen === 5) ? 0 : getInventory(pen, "F", d);

      const rateM = getRate(pen, "M", d);
      const rateF = (pen === 5) ? 0 : getRate(pen, "F", d);

      const feedM = round1(invM * rateM);
      const feedF = round1(invF * rateF);

      const penLabel = (pen === 5) ? "Spares" : `Pen ${pen}`;

      rows.push(`
        <tr>
          <td>${penLabel}</td>
          <td>${invM}</td><td>${rateM || 0}</td><td>${feedM}</td>
          <td>${invF}</td><td>${rateF || 0}</td><td>${feedF}</td>
        </tr>
      `);
    }

    tbody.innerHTML = rows.join("");
  }

  // Summary
  let summaryMode = state.summaryMode || "daily";
  function setSummaryMode(mode){
    summaryMode = mode;
    $("sumDaily").classList.toggle("selectedBlue", mode==="daily");
    $("sumWeekly").classList.toggle("selectedBlue", mode==="weekly");
    state.summaryMode = mode;
    persistState();
    renderSummary();
  }
  $("sumDaily").onclick = ()=> setSummaryMode("daily");
  $("sumWeekly").onclick = ()=> setSummaryMode("weekly");

  function eggTotalsRangeForPen(startDate, endDate, pen){
    let nest=0,floor=0,dirty=0,crack=0,dbl=0,cull=0;
    for (const r of records){
      if (!inRangeDate(r.date, startDate, endDate)) continue;
      if (r.pen !== pen) continue;

      if (r.kind==="egg_nest") nest++;
      if (r.kind==="egg_floor") floor++;
      if (r.kind==="egg_defect"){
        if (r.defectType==="Dirty") dirty++;
        if (r.defectType==="Cracked") crack++;
        if (r.defectType==="Double") dbl++;
        if (r.defectType==="Cull") cull++;
      }
    }
    return { nest, floor, total: nest+floor, dirty, crack, dbl, cull };
  }

  function feedComputedForDate(pen, dateStr){
    const invM = getInventory(pen, "M", dateStr);
    const invF = (pen===5) ? 0 : getInventory(pen, "F", dateStr);
    const rateM = getRate(pen, "M", dateStr);
    const rateF = (pen===5) ? 0 : getRate(pen, "F", dateStr);

    return {
      invM, invF,
      rateM, rateF,
      feedM: invM * rateM,
      feedF: invF * rateF
    };
  }

  function feedComputedForRange(pen, startDate, endDate){
    // sum daily feed
    let totalM = 0, totalF = 0;

    // track last rate sources
    let lastRateM = 0, lastRateF = 0;

    let cur = startDate;
    while (dateToInt(cur) <= dateToInt(endDate)){
      const x = feedComputedForDate(pen, cur);
      totalM += x.feedM;
      totalF += x.feedF;
      lastRateM = x.rateM;
      lastRateF = x.rateF;
      cur = addDays(cur, 1);
    }

    return {
      totalM,
      totalF,
      rateM: lastRateM,
      rateF: lastRateF
    };
  }

  function renderSummary(){
    const d = dateEl.value || todayStr;

    const start = (summaryMode === "weekly") ? startOfWeek(d) : d;
    const end   = (summaryMode === "weekly") ? addDays(start, 5) : d;

    if (summaryMode === "weekly") {
      $("sumEggTitle").textContent = `Egg Summary (Week Ending ${end})`;
      $("sumMortTitle").textContent = `Mortality Summary (Week Ending ${end})`;
      $("sumFeedTitle").textContent = `Feed Summary (Week Ending ${end})`;
    } else {
      $("sumEggTitle").textContent = `Egg Summary (${d})`;
      $("sumMortTitle").textContent = `Mortality Summary (${d})`;
      $("sumFeedTitle").textContent = `Feed Summary (${d})`;
    }

    // Eggs summary table
    const eggBody = [];
    for (let pen=1; pen<=4; pen++){
      const t = eggTotalsRangeForPen(start, end, pen);
      eggBody.push(`
        <tr>
          <td>Pen ${pen}</td>
          <td>${t.nest}</td><td>${t.floor}</td><td>${t.total}</td>
          <td>${t.dirty}</td><td>${t.crack}</td><td>${t.dbl}</td><td>${t.cull}</td>
        </tr>
      `);
    }
    $("eggSummaryTable").innerHTML = eggBody.join("");

    // Mortality summary table
    const mortBody = [];
    for (let pen=1; pen<=5; pen++){
      const t = sumMortalityFor(pen, start, end);
      mortBody.push(`
        <tr>
          <td>${pen===5 ? "Spares" : "Pen " + pen}</td>
          <td>${t.deadM}</td><td>${t.deadF}</td><td>${t.cullM}</td><td>${t.cullF}</td>
        </tr>
      `);
    }
    $("mortSummaryTable").innerHTML = mortBody.join("");

    // Feed summary table
    const feedBody = [];
    for (let pen=1; pen<=5; pen++){
      const f = (summaryMode === "weekly")
        ? feedComputedForRange(pen, start, end)
        : feedComputedForRange(pen, d, d);

      const mLb = round1(f.totalM);
      const fLb = round1(f.totalF);
      const total = round1(f.totalM + f.totalF);

      feedBody.push(`
        <tr>
          <td>${pen===5 ? "Spares" : "Pen " + pen}</td>
          <td>${mLb}</td><td>${f.rateM || 0}</td>
          <td>${fLb}</td><td>${(pen===5 ? 0 : (f.rateF || 0))}</td>
          <td>${total}</td>
        </tr>
      `);
    }
    $("feedSummaryTable").innerHTML = feedBody.join("");
  }

  // Admin UI load/save
  function loadAdminInputs(){
    const d = dateEl.value || todayStr;
    for (let pen=1; pen<=5; pen++){
      const pm = getPlaced(pen, "M", d);
      const pf = (pen===5) ? 0 : getPlaced(pen, "F", d);
      $("placed"+pen+"M").value = pm || 0;
      if (pen !== 5) $("placed"+pen+"F").value = pf || 0;

      const rm = getRate(pen, "M", d);
      const rf = (pen===5) ? 0 : getRate(pen, "F", d);
      $("rate"+pen+"M").value = rm || 0;
      if (pen !== 5) $("rate"+pen+"F").value = rf || 0;
    }
  }

  function logSetting(kind, pen, sex, value){
    const m = baseMeta();
    const evt = { ...m, kind, pen, sex, value: safeNum(value, 0) };
    logEvent(evt, `${kind.toUpperCase()} ${pen} ${sex} = ${evt.value}`);
  }

  $("savePlaced").onclick = ()=>{
    if (!adminUnlocked) { alert("Unlock Admin first."); return; }
    for (let pen=1; pen<=5; pen++){
      logSetting("placed", pen, "M", $("placed"+pen+"M").value);
      if (pen !== 5) logSetting("placed", pen, "F", $("placed"+pen+"F").value);
    }
    alert("Birds placed saved.");
    loadAdminInputs();
    pushSettingsToCloud();
  };

  $("saveRates").onclick = ()=>{
    if (!adminUnlocked) { alert("Unlock Admin first."); return; }
    for (let pen=1; pen<=5; pen++){
      logSetting("rate", pen, "M", $("rate"+pen+"M").value);
      if (pen !== 5) logSetting("rate", pen, "F", $("rate"+pen+"F").value);
    }
    alert("Feed rates saved.");
    loadAdminInputs();
    pushSettingsToCloud();
  };

  $("clearAll").onclick = ()=>{
    if (!adminUnlocked) { alert("Unlock Admin first."); return; }
    const ok = confirm("This will permanently delete ALL data in this browser for FlockFlow v8. Continue?");
    if (!ok) return;
    records = [];
    saveRecords();
    lastLoggedEl.textContent = "Cleared all data";
    alert("Data cleared.");
    updateEggPenKpis();
    refreshMortalityPanel();
    renderFeedTable();
    renderSummary();
  };

  $("savePin").onclick = ()=>{
    if (!adminUnlocked) { alert("Unlock Admin first."); return; }
    const np = $("newPin").value.trim();
    if (!np) { alert("Enter a new PIN."); return; }
    adminPin = np;
    $("newPin").value = "";
    persistState();
    alert("PIN updated.");
  };

document.getElementById("btnCloudPull").onclick = async ()=>{
  await pullSettingsFromCloud();
  // If events autosync is OFF, allow manual one-time event pull without enabling autosync.
  if (autosyncEventsEnabled || confirm("Also pull Eggs + Mortality events now? (does not change Autosync toggle)")) {
    const r = getSyncRange();
    await pullEventsForRange(r.start, r.end);
  }
};
document.getElementById("btnGlobalSignOut").onclick = sbSignOut;

  // --- Egg/Mort autosync toggle + Master mode flow ---
  function enumerateDateStrings(startStr, endStr){
    const out = [];
    const d0 = new Date(startStr + "T00:00:00");
    const d1 = new Date(endStr   + "T00:00:00");
    for (let d = new Date(d0); d <= d1; d.setDate(d.getDate() + 1)){
      out.push(d.toISOString().slice(0,10));
    }
    return out;
  }

  async function masterOverwritePushRange(startStr, endStr){
    const dates = enumerateDateStrings(startStr, endStr);
    for (const ds of dates){
      await pushEventsForDateOverwrite(ds);
    }
  }

  async function enableEventsAutosyncFlow(){
    const choice = prompt(
      "Enable Autosync for Eggs + Mortality\n\n" +
      "Type 1, 2, or 3:\n" +
      "1) MASTER autosync (PUSH local → cloud first, then PULL)\n" +
      "2) NORMAL autosync (PULL cloud → overwrite this device first)\n" +
      "3) Cancel"
    );
    if (!choice) return "cancel";
    if (choice.trim() === "1") return "master";
    if (choice.trim() === "2") return "normal";
    return "cancel";
  }

  async function applyEventsAutosyncMode(mode){
    const r = getSyncRange();
    if (mode === "master") {
      await masterOverwritePushRange(r.start, r.end);
      await pullEventsForRange(r.start, r.end);
    } else if (mode === "normal") {
      await pullEventsForRangeOverwriteLocal(r.start, r.end);
    }
  }

  const tog = document.getElementById("togEventsAuto");
  if (tog){
    tog.checked = !!autosyncEventsEnabled;
    tog.onchange = async ()=>{
      if (tog.checked){
        const mode = await enableEventsAutosyncFlow();
        if (mode === "cancel"){
          tog.checked = false;
          autosyncEventsEnabled = false;
          localStorage.setItem("autosyncEventsEnabled", "false");
          return;
        }
        autosyncEventsEnabled = true;
        localStorage.setItem("autosyncEventsEnabled", "true");
        eventsAutosyncStartupMode = mode;
        localStorage.setItem("eventsAutosyncStartupMode", mode);

        try {
          await applyEventsAutosyncMode(mode);
          alert(mode === "master"
            ? "Autosync ON (MASTER). Pushed local events to cloud, then pulled."
            : "Autosync ON (NORMAL). Pulled cloud events and overwrote this device for the range."
          );
        } catch(e){
          alert("Autosync enable failed: " + e.message);
        }
      } else {
        autosyncEventsEnabled = false;
        localStorage.setItem("autosyncEventsEnabled", "false");
        alert("Egg + Mortality autosync is OFF. Settings still autosync.");
      }
    };
  }

  const btnMasterPush = document.getElementById("btnMasterPushNow");
  if (btnMasterPush){
    btnMasterPush.onclick = async ()=>{
      if (!adminUnlocked) { alert("Unlock Admin first."); return; }
      const ok = confirm(
        "WARNING:\n\nThis will OVERWRITE cloud egg + mortality data with THIS device's data " +
        "for the current sync range.\n\nContinue?"
      );
      if (!ok) return;
      const r = getSyncRange();
      await masterOverwritePushRange(r.start, r.end);
      alert("Master Push completed.");
    };
  }

  // Full history sync button — pulls last 90 days in weekly chunks to avoid memory overflow
  const btnFullHistory = document.getElementById("btnFullHistorySync");
  if (btnFullHistory) {
    btnFullHistory.onclick = async () => {
      setSyncStatus(`Syncing full history...`);
      await pullSettingsFromCloud();
      // Pull 90 days in 2-week chunks
      let chunkEnd = addDays(todayStr, 1);
      let chunkStart = addDays(chunkEnd, -14);
      const hardStop = addDays(todayStr, -90);
      while (dateToInt(chunkEnd) > dateToInt(hardStop)) {
        const start = dateToInt(chunkStart) < dateToInt(hardStop) ? hardStop : chunkStart;
        await pullEventsForRange(start, chunkEnd);
        chunkEnd = addDays(chunkStart, -1);
        chunkStart = addDays(chunkEnd, -14);
      }
      setSyncStatus(`Last sync: ${fmtTime()} (full history complete)`);
    };
  }

  // Flush aggressively when tab becomes visible or device comes back online
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible" && currentSession) {
      scheduleSync("focus");
    }
  });
  window.addEventListener("online", () => {
    if (currentSession) scheduleSync("online");
  });

  // Exports
  function downloadText(filename, content){
    const blob = new Blob([content], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function csvEscape(x){
    const s = (x === null || x === undefined) ? "" : String(x);
    if (s.includes(",") || s.includes('"') || s.includes("\n")) return `"${s.replaceAll('"','""')}"`;
    return s;
  }

  $("exportDetail").onclick = ()=>{
    const cols = [
      "tsISO","tsLocal","date","caretaker","kind",
      "round","pen","box","hole","nestId",
      "defectType",
      "action","sex",
      "value","count"
    ];
    const lines = [cols.join(",")];
    for (const r of records){
      lines.push(cols.map(c => csvEscape(r[c])).join(","));
    }
    downloadText(`house_logger_detail_${dateEl.value||todayStr}.csv`, lines.join("\n"));
  };

  $("exportSummary").onclick = ()=>{
    const d = dateEl.value || todayStr;
    const start = (summaryMode === "weekly") ? startOfWeek(d) : d;
    const end   = (summaryMode === "weekly") ? addDays(start, 6) : d;

    const lines = [];
    lines.push(`Summary Mode,${summaryMode}`);
    lines.push(`Start Date,${start}`);
    lines.push(`End Date,${end}`);
    lines.push("");

    lines.push("Egg Summary");
    lines.push("Pen,Nest,Floor,Total,Dirty,Cracked,Double,Cull");
    for (let pen=1; pen<=4; pen++){
      const t = eggTotalsRangeForPen(start, end, pen);
      lines.push([`Pen ${pen}`,t.nest,t.floor,t.total,t.dirty,t.crack,t.dbl,t.cull].join(","));
    }
    lines.push("");

    lines.push("Mortality Summary");
    lines.push("Pen,Dead Male,Dead Female,Culled Male,Culled Female");
    for (let pen=1; pen<=5; pen++){
      const t = sumMortalityFor(pen, start, end);
      lines.push([pen===5?"Spares":`Pen ${pen}`, t.deadM, t.deadF, t.cullM, t.cullF].join(","));
    }
    lines.push("");

    lines.push("Feed Summary (computed)");
    lines.push("Pen,Male Feed (lb),Male Rate,Female Feed (lb),Female Rate,Total Feed (lb)");
    for (let pen=1; pen<=5; pen++){
      const f = (summaryMode === "weekly")
        ? feedComputedForRange(pen, start, end)
        : feedComputedForRange(pen, d, d);

      const mLb = round1(f.totalM);
      const fLb = round1(f.totalF);
      const total = round1(f.totalM + f.totalF);
      lines.push([
        pen===5?"Spares":`Pen ${pen}`,
        mLb, f.rateM || 0,
        fLb, (pen===5 ? 0 : (f.rateF || 0)),
        total
      ].join(","));
    }

    downloadText(`house_logger_summary_${dateEl.value||todayStr}.csv`, lines.join("\n"));
  };

  // Date and caretaker interactions
  dateEl.onchange = ()=>{
    round = 1;
    roundEl.textContent = "1";
    persistState();

    updateEggPenKpis();
    refreshMortalityPanel();
    renderFeedTable();
    renderSummary();
    if (adminUnlocked) loadAdminInputs();
  };
  caretakerEl.oninput = ()=> persistState();

  // INIT (order matters)
  applyTheme();

  roundEl.textContent = String(round);
  activeBoxEl.textContent = activeBox || "(none)";

  renderBoxes();
  renderHoles(); // guarantees holes show
  setActiveBox(activeBox);
  setEggPen(eggPen);
  setMortPen(mortPen);

  refreshAdmin();
  updateEggPenKpis();
  refreshMortalityPanel();
  renderFeedTable();

  setSummaryMode(summaryMode);
  renderSummary();

  if (adminUnlocked) loadAdminInputs();

  showTab("tabEggs");
})();
</script>
</body>
</html>